<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>浅谈Android Broadcast | PassersHowe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="前言：本文所写的是博主的个人见解，如有错误或者不恰当之处，欢迎私信博主，加以改正！demo链接
广播简述Android应用程序可以发送或者接收来自 Android 系统和其他 Android 应用程序的广播消息，类似于发布订阅设计模式。当感兴趣的事件发生时，这些广播被发送。例如，Android 系统在各种系统事件发生时发送广播，比如系统启动或者设备开始充电等。应用程序还可以发送自定义的广播，比如通">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈Android Broadcast">
<meta property="og:url" content="http://www.passershowe.com/2017/04/05/Android-BroadcastReceiver/index.html">
<meta property="og:site_name" content="PassersHowe">
<meta property="og:description" content="前言：本文所写的是博主的个人见解，如有错误或者不恰当之处，欢迎私信博主，加以改正！demo链接
广播简述Android应用程序可以发送或者接收来自 Android 系统和其他 Android 应用程序的广播消息，类似于发布订阅设计模式。当感兴趣的事件发生时，这些广播被发送。例如，Android 系统在各种系统事件发生时发送广播，比如系统启动或者设备开始充电等。应用程序还可以发送自定义的广播，比如通">
<meta property="og:updated_time" content="2017-04-18T02:52:19.910Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="浅谈Android Broadcast">
<meta name="twitter:description" content="前言：本文所写的是博主的个人见解，如有错误或者不恰当之处，欢迎私信博主，加以改正！demo链接
广播简述Android应用程序可以发送或者接收来自 Android 系统和其他 Android 应用程序的广播消息，类似于发布订阅设计模式。当感兴趣的事件发生时，这些广播被发送。例如，Android 系统在各种系统事件发生时发送广播，比如系统启动或者设备开始充电等。应用程序还可以发送自定义的广播，比如通">
  
    <link rel="alternate" href="/atom.xml" title="PassersHowe" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">PassersHowe</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://www.passershowe.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-BroadcastReceiver" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/05/Android-BroadcastReceiver/" class="article-date">
  <time datetime="2017-04-05T09:02:29.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      浅谈Android Broadcast
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前言：本文所写的是博主的个人见解，如有错误或者不恰当之处，欢迎私信博主，加以改正！<a href="https://github.com/PassersHowe/BlogDemo" target="_blank" rel="external">demo链接</a></p>
<h3 id="广播简述"><a href="#广播简述" class="headerlink" title="广播简述"></a>广播简述</h3><p>Android应用程序可以发送或者接收来自 Android 系统和其他 Android 应用程序的广播消息，类似于发布订阅设计模式。当感兴趣的事件发生时，这些广播被发送。例如，Android 系统在各种系统事件发生时发送广播，比如系统启动或者设备开始充电等。应用程序还可以发送自定义的广播，比如通知其他应用可能感兴趣的内容(例如，一些新数据已被下载)。</p>
<p>应用程序可以注册接收特定的广播，当发送广播时，系统自动将广播路由到订阅该特定类型广播的应用程序。一般来说，广播可以用作跨应用程序和正常用户流之外的消息传递系统。</p>
 <a id="more"></a>
<the rest="" of="" contents="" |="" 余下全文="">

<h3 id="系统广播"><a href="#系统广播" class="headerlink" title="系统广播"></a>系统广播</h3><p>当发生各种系统事件时,系统会自动发送广播，例如系统切换飞行模式时，系统广播被发送到所有接收订阅事件的应用程序。</p>
<p>广播消息本身被包裹在一个 Intent 对象的动作字符串标识（例如 android.intent.action.AIRPLANE_MODE ）。这个 Intent 还可以包括附加到其额外字段中的附加信息。比如，”飞行模式” 的 Intent 包括一个 boolean 额外指示是否 “飞行模式”。</p>
<p>系统广播行为的完整列表，请参阅 Android SDK 中的 BROADCAST_ACTIONS.TXT 文件。每个广播行为都有与之关联的常量字段，例如常量 ACTION_AIRPLANE_MODE_CHANGED 的值为 android.intent.action.AIRPLANE_MODE，每个广播动作的文档都可以在其相关联的常量字段中获得。</p>
<p>注：系统广播更改<br>Android 7 和更高的不再发送以下系统广播。这种优化影响所有的应用程序，不仅那些针对Android 7。</p>
<ul>
<li>ACTION_NEW_PICTURE</li>
<li>ACTION_NEW_VIDEO<br>针对 Android 7 的应用程序（API级别24）和更高的必须登记以下的广播代码注册广播接收器（BroadcastReceiver ，<br>IntentFilter）。在清单中声明接收器不起作用。</li>
<li>CONNECTIVITY_ACTION</li>
</ul>
<h3 id="注册接收广播"><a href="#注册接收广播" class="headerlink" title="注册接收广播"></a>注册接收广播</h3><p>应用程序可以通过两种方式接收广播：通过清单声明的接收者和上下文注册的接收者</p>
<ol>
<li><p>清单声明的接收器(静态注册)</p>
<p>在清单中声明广播接收者，可以通过下面的步骤：<br>(1)在应用程序的清单中指定 <code>&lt;receiver&gt;</code> 元素</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;receiver</div><div class="line">         android:name=".DemoBroadcastReceiver"</div><div class="line">         android:exported="true"&gt;</div><div class="line">       &lt;intent-filter&gt;</div><div class="line">           &lt;action android:name="NOTIFICATION_DEMO"/&gt;</div><div class="line">      </div><div class="line">       &lt;/intent-filter&gt;</div><div class="line">           </div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>intent-filter (意图过滤器) 指定你的接收者订阅的广播操作。</p>
<p>(2)继承 BroadcastReceiver 并实现 onReceive（Context，Intent） 方法，请看下面的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line">     <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DemoBroadcastReceiver"</span>;</div><div class="line">     </div><div class="line">     <span class="meta">@Override</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</div><div class="line">         StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">         sb.append(<span class="string">"Action: "</span> + intent.getAction() + <span class="string">"\n"</span>);</div><div class="line">         sb.append(<span class="string">"URI: "</span> + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + <span class="string">"\n"</span>);</div><div class="line">         String log = sb.toString();</div><div class="line">         Log.d(TAG, log);</div><div class="line">         Toast.makeText(context, log, Toast.LENGTH_LONG).show();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当应用程序安装时，系统包管理器注册接受器，然后接收器将成为你的应用程序的单独入口，这意味着如果应用程序当前未运行，系统可以启动你的应用程序并发送广播。</p>
<p>系统将创建一个新的 BroadcastReceiver 组件对象来处理它接收的每个广播。这个对象仅对调用 onReceive（Context，Intent）的时候有效。当你在代码从该方法返回，系统将认为组件不再活动。</p>
</li>
<li><p>context 注册接收者(动态注册)  </p>
<p>用context注册接收器，可以通过以下几个步骤：</p>
<p>(1) 创建 BroadcastReceiver 并实例化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">BroadcastReceiver broadcastReceiver = <span class="keyword">new</span> DemoBroadcastReceiver();</div></pre></td></tr></table></figure>
<p>(2) 创建一个 IntentFilter 并调用 registerReceiver( BroadcastReceiver , IntentFilter ) 来注册接收器</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</div><div class="line">intentFilter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED);</div><div class="line"><span class="keyword">this</span>.registerReceiver(broadcastReceiver,intentFilter);</div></pre></td></tr></table></figure>
<p>注意：要注册本地广播，请改用 LocalBroadcastManager.registerReceiver( BroadcastReceiver , IntentFilter )。</p>
<p>如果context注册有效时，context注册的接收者就可以接收广播。例如你在 Activity 的 context 中注册，只要 Activity 没有被销毁，就会收到广播。如果是使用 ApplicationContext 进行注册，只要程序在运行就可以收到广播。</p>
<p>(3)停止接收广播时，可以调用 unregisterReceiver( android.content.BroadcastReceiver ) 进行注销。当你不需要这个广播时或者 context 不再有效时，一定要注销接收器。·</p>
<p>注意你在哪里注册和注销的接收者，比如，你在 Activity 的 onCreate( Bundle ) 中注册一个接收者，则应该在 onDestory() 中注销它，防止接收器泄露；如果你在 onResume() 中注册一个接收器，你应该在 onPause() 中注销，以防止多次注册( 如果你不想在 Activity 暂停时接收广播，可以做减少不必要的系统开销 )。不要在 onSaveInstanceState( Bundle ) 中注销，如果用户在历史栈中移回，则不会调用这个方法。</p>
</li>
<li><p>进程状态的影响</p>
<p>BroadcastReceiver 的状态(无论是否在运行)会影响其包含进程的状态，这也可能反过来影响其被系统杀死的可能性。例如，当进程执行一个接收器时(在其 onReceive() 方法中运行代码)，它被认为是一个前台进程，除非内存压力极度大的时候，否则系统将保持其进程的运行。</p>
<p>然而，一旦你的代码从 onREceive() 方法中返回, BroadcastReceiver 就不在活动了。接收器的宿主进程变得和运行在这个进程中的其它应用程序组件一样重要。如果该进程只承载一个 manifest-declared 接收器(应用程序从来没有或者最近没有跟用户进行交互)，然后从 onReceive() 返回时，系统将认为它的进程是一个低优先级的进程，很可能会杀死它，从而施放资源，用于其它优先级高的进程。</p>
<p>因此，不应该在广播接收器中执行耗时的后台线程，在执行 onReceive() 后，系统随时可以杀死进程以回收内存，这样做会终止在该进程中运行生成的线程。为了避免这种情况的发生，应该调用 goAsync() 方法(如果你需要更多的时间来处理后台线程中的广播)或使用 JobScheduler 从接收器调度 JobService ，则系统会知道该进程继续执行工作。</p>
<p>下面的这段代码显示了一个 BroadcastReceiver 使用 goAsync() 来标记，需要更多的时间来完成当前的操作，并在完成后再 onReceiver() 。如果你在 onReceive() 中需要的时间很长，导致 UI 线程错过了一帧( 16 ms )，可以使用上面的方法，在后台线程继续工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoBroadcastReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"DemoBroadcastReceiver"</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, <span class="keyword">final</span> Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> PendingResult pendingResult = goAsync();</div><div class="line"></div><div class="line">        AsyncTask&lt;String, Integer, String&gt; asyncTask = <span class="keyword">new</span> AsyncTask&lt;String, Integer, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> String <span class="title">doInBackground</span><span class="params">(String... params)</span> </span>&#123;</div><div class="line">                StringBuilder sb = <span class="keyword">new</span> StringBuilder();</div><div class="line">                sb.append(<span class="string">"Action: "</span> + intent.getAction() + <span class="string">"\n"</span>);</div><div class="line">                sb.append(<span class="string">"URI: "</span> + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + <span class="string">"\n"</span>);</div><div class="line">                String log = sb.toString();</div><div class="line">                Log.d(TAG, log);</div><div class="line"></div><div class="line">                <span class="comment">// 必须调用 finish() ，以便 BroadcastReceiver 可以被回收。</span></div><div class="line">                pendingResult.finish();</div><div class="line"></div><div class="line">                <span class="keyword">return</span> log;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        asyncTask.execute();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="发送广播"><a href="#发送广播" class="headerlink" title="发送广播"></a>发送广播</h3><p>Android 提供了三种方法供应用发送广播：</p>
<ul>
<li><p>sendOrderedBroadcast( Intent , String ) 方法将广播发送到一个接收器。随着每个接收器依次执行，它可以将结果传递到下一个接收器，也可以完全中止广播，使它不会传给其他接收器。Android 可以控制运行的命令接收器：匹配 intent-filter 的优先级属性；具备相同优先级的接收器，可以任意顺序运行</p>
</li>
<li><p>sendBroadcast( Intent ) 方法向所有接收器发送未确定顺序的广播，这被成为普通广播。这种广播更有效率，但是意味着接收器不能读取来自其他接收器的结果，传播从广播接收的数据，或者中止广播</p>
</li>
<li><p>LocalBroadcastManager.sendBroadcast 方法将广播发送到同个应用程序中的接收者。如果你不需要发送跨应用广播，请使用本地广播。实施 效率更高(无需进行跨进程通信)，不需要担心其他可以接收或者发送广播的应用程序之间的任何安全问题</p>
</li>
</ul>
<p>下面的代码片段演示了如何通过创建 Intent 并 调用sendBroadcast( Intent ) 来发送广播：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent();</div><div class="line">intent.setAction(<span class="string">"NOTIFICATION_DEMO"</span>);</div><div class="line">intent.putExtra(<span class="string">"data"</span>,<span class="string">"Send a notice"</span>);</div><div class="line">sendBroadcast(intent);</div></pre></td></tr></table></figure>
<p>广播消息被包装在 Intent 对象中，Intent 动作字符串必须提供应用程序的 java 包名和唯一的广播事件标识。你可以使用 putExtra( String , Bundle ) 附加信息到 Intent 中，还可以通过 Intent 调用 setPackage( String ) 将广播限制在同一组织中的一组应用程序。</p>
<p>注意：虽然 Intent 用于发送广播和使用 startActivity( Intent ) 启动 Activity ，但这些行为是完全无关的。广播接收器无法看到或者捕获用于开始 Activity 的 Intent ；同样，当你是广播 Intent 时，是无法找到或启动 Activity 。</p>
<h3 id="广播权限约束"><a href="#广播权限约束" class="headerlink" title="广播权限约束"></a>广播权限约束</h3><p>Permissions(权限) 允许你将广播限制为持有一定权限的应用程序集。可以对广播的发送方或接收方强制执行限制。 </p>
<ol>
<li><p>发送权限<br>当你调用 sendBroadcast( Intent , String ) 或 sendOrderedBroadcast( Intent , String , BroadcastReceiver , Handle , int , String , Bundle ) 时，可以指定权限参数。只有通过其清单中的标签请求许可的接收器才能接收广播。例如，以下代码发送广播：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sendBroadcast(<span class="keyword">new</span> Intent(<span class="string">"com.passershowe.broadcast.NOTIFY"</span>),      Manifest.permission.SEND_SMS);</div></pre></td></tr></table></figure>
<p>要接收广播，接收应用程序必须请求如下所示的权限：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.SEND_SMS"</span>/&gt;</div></pre></td></tr></table></figure>
<p>你可以指定一个现有的系统权限（如SEND_SMS）或使用 <code>&lt;permission&gt;</code>元素定义自定义权限</p>
<p>注意：当你的应用程序注册了自定义权限，你必须在使用这个权限前，安装它</p>
</li>
<li><p>接收权限<br>如果你在注册广播接收器(或者使用 registerReceiver( BroadcastReceiver , IntentFilter , String , Handle ) 或清单中的 <code>&lt;receiver&gt;</code> 标签)中指定权限参数，则只有使用 <code>&lt;uses-permission&gt;</code> 标签在其清单中(随后被授予许可是危险的)可以向接收者发送 Intent </p>
<p>例如，假设你的接收应用程序具有清单声明的接收器，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;receiver android:name=".DemoBroadcastReceiver"</div><div class="line">               android:permission="android.permission.SEND_SMS"&gt;</div><div class="line">        &lt;intent-filter&gt;</div><div class="line">            &lt;action android:name="android.intent.action.AIRPLANE_MODE"/&gt;</div><div class="line">        &lt;/intent-filter&gt;</div><div class="line">&lt;/receiver&gt;</div></pre></td></tr></table></figure>
<p>或者你的接收应用程序具有 context 注册的接收器，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">IntentFilter filter = <span class="keyword">new</span> IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);</div><div class="line">registerReceiver(receiver, filter, Manifest.permission.SEND_SMS, <span class="keyword">null</span> );</div></pre></td></tr></table></figure>
<p>然后，为了能够向这些接收者发送广播，发送应用程序必须如下所示请求许可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;uses-permission android:name=<span class="string">"android.permission.SEND_SMS"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
</the>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://www.passershowe.com/2017/04/05/Android-BroadcastReceiver/" data-id="ck1ork5oz00036gssspqw4ssp" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/04/11/Android-Service/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          浅谈 Android Service
        
      </div>
    </a>
  
  
    <a href="/2017/03/26/Android-Activity/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">浅谈Android Activity的生命周期</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Other/">Other</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 20px;">Android</a> <a href="/tags/Other/" style="font-size: 10px;">Other</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/10/08/Find-Work/">找工作找创熠地产</a>
          </li>
        
          <li>
            <a href="/2017/04/24/Android-MVP/">谈谈 Android MVP 架构</a>
          </li>
        
          <li>
            <a href="/2017/04/19/Android-ANR/">了解 Android ANR</a>
          </li>
        
          <li>
            <a href="/2017/04/16/Android-Thread/">了解 Android 的进程和线程</a>
          </li>
        
          <li>
            <a href="/2017/04/11/Android-Service/">浅谈 Android Service</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 洪俊豪(PassersHowe)<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>